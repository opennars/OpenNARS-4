name: NAL Rules

rules:
  nal1: |
    {<M --> P>. <S --> M>} |- <S --> P> .ded
    {<P --> M>. <M --> S>} |- <P --> S> .ded'
    {<M --> P>. <M --> S>} |- <S --> P> .ind
    {<M --> P>. <M --> S>} |- <P --> S> .ind'
    {<P --> M>. <S --> M>} |- <S --> P> .abd
    {<P --> M>. <S --> M>} |- <P --> S> .abd'
    {<P --> M>. <M --> S>} |- <S --> P> .exe
    {<M --> P>. <S --> M>} |- <P --> S> .exe'

  nal2: |
    {<M <-> P>. <S <-> M>} |- <S <-> P> .res
    {<M <-> P>. <M <-> S>} |- <S <-> P> .res
    {<P <-> M>. <S <-> M>} |- <S <-> P> .res
    {<P <-> M>. <M <-> S>} |- <S <-> P> .res
    {<M --> P>. <M --> S>} |- <S <-> P> .com
    {<P --> M>. <S --> M>} |- <S <-> P> .com'
    {<M --> P>. <S <-> M>} |- <S --> P> .ana
    {<M --> P>. <M <-> S>} |- <S --> P> .ana
    {<P --> M>. <S <-> M>} |- <P --> S> .ana
    {<P --> M>. <M <-> S>} |- <P --> S> .ana
    {<M <-> P>. <S --> M>} |- <S --> P> .ana'
    {<P <-> M>. <S --> M>} |- <S --> P> .ana'
    {<M <-> P>. <M --> S>} |- <P --> S> .ana'
    {<P <-> M>. <M --> S>} |- <P --> S> .ana'

  nal3: |
    {<S --> P>. <P --> S>} |- <S <-> P> .int
    {<S --> P>. <P --> S>} |- <P <-> S> .int
    # 'composition
    {<M --> T1>. <M --> T2>} |- <M --> (&, T1, T2)> .int
    {<T1 --> M>. <T2 --> M>} |- <(|, T1, T2) --> M> .int
    {<M --> T1>. <M --> T2>} |- <M --> (|, T1, T2)> .uni
    {<T1 --> M>. <T2 --> M>} |- <(&, T1, T2) --> M> .uni
    {<M --> T1>. <M --> T2>} |- <M --> (-, T1, T2)> .dif
    {<M --> T1>. <M --> T2>} |- <M --> (-, T2, T1)> .dif'
    {<T1 --> M>. <T2 --> M>} |- <(~, T1, T2) --> M> .dif
    {<T1 --> M>. <T2 --> M>} |- <(~, T2, T1) --> M> .dif'
    # 'decomposition
    {(--, <M --> (&, T1, T2)>). <M --> T1>} |- (--, <M --> T2>) .ded
    # 'TODO: need alternative syntax for decomposition
    # 'i.e. {(--, <M --> (&, T1, T2)>). <M --> _T1>} |- (--, <M --> ((&, T1, T2) - _T1)>) .ded
    {(--, <M --> (&, T2, T1)>). <M --> T1>} |- (--, <M --> T2>) .ded
    {<M --> (|, T1, T2)>. (--, <M --> T1>)} |- <M --> T2> .ded
    {<M --> (|, T2, T1)>. (--, <M --> T1>)} |- <M --> T2> .ded
    {(--, <M --> (-, T1, T2)>). <M --> T1>} |- <M --> T2> .ded
    {(--, <M --> (-, T2, T1)>). (--, <M --> T1>)} |- (--, <M --> T2>) .ded
    {(--, <(|, T2, T1) --> M>). <T1 --> M>} |- (--, <T2 --> M>) .ded
    {(--, <(|, T1, T2) --> M>). <T1 --> M>} |- (--, <T2 --> M>) .ded
    {<(&, T2, T1) --> M>. (--, <T1 --> M>)} |- <T2 --> M> .ded
    {<(&, T1, T2) --> M>. (--, <T1 --> M>)} |- <T2 --> M> .ded
    {(--, <(~, T1, T2) --> M>). <T1 --> M>} |- <T2 --> M> .ded
    {(--, <(~, T2, T1) --> M>). (--, <T1 --> M>)} |- (--, <T2 --> M>) .ded
    {(--, (&&, T1, T2)). T1} |- (--, T2) .ded
    {(--, (&&, T2, T1)). T1} |- (--, T2) .ded
    {(||, T1, T2). (--, T1)} |- T2 .ded
    {(||, T2, T1). (--, T1)} |- T2 .ded
    # possibly wrong -- double check two rules below
    # see test_elimination_3 in test_NAL6.py
    {(&&, T1, T2). T1} |- T2 .ded
    {(&&, T2, T1). T1} |- T2 .ded

  conditional_syllogistic: |
    {<S ==> P>. S} |- P .ded
    {<P ==> S>. S} |- P .abd
    {S. <S ==> P>} |- P .ded'
    {S. <P ==> S>} |- P .abd'
    {S. <S <=> P>} |- P .ana
    {S. <P <=> S>} |- P .ana
    {<S <=> P>. S} |- P .ana'
    {<P <=> S>. S} |- P .ana'

  nal5: |
    # 'conditional conjunctive
    # '(C ^ S) => P, S |- C => P (alternative syntax below)
    {<(&&, C, S) ==> P>. _S} |- <((&&, C, S) - _S) ==> P> .ded
    {<(&&, S, C) ==> P>. _S} |- <((&&, S, C) - _S) ==> P> .ded
    # 'inverse TODO: need a better way to handle variations
    # 'IDEA: generate variations when rules are loaded
    {<P ==> (&&, C, S)>. _S} |- <P ==> ((&&, C, S) - _S)> .ded
    {<P ==> (&&, S, C)>. _S} |- <P ==> ((&&, S, C) - _S)> .ded

    # '(C ^ S) => P, M => S |- (C ^ M) => P (alternative syntax below)
    {<(&&, C, S) ==> P>. <M ==> _S>} |- <(&&, ((&&, C, S) - _S), M) ==> P> .ded
    {<(&&, S, C) ==> P>. <M ==> _S>} |- <(&&, ((&&, S, C) - _S), M) ==> P> .ded

    # '(C ^ S) => P, C => P |- S (alternative syntax below)
    {<(&&, C, S) ==> P>. <_C ==> P>} |- ((&&, C, S) - _C) .abd
    {<(&&, S, C) ==> P>. <_C ==> P>} |- ((&&, S, C) - _C) .abd

    # '(C ^ S) => P, (C ^ M) => P |- M => S (alternative syntax below)
    {<(&&, C, S) ==> P>. <(&&, _C, M) ==> P>} |- <((&&, _C, M) - C) ==> ((&&, C, S) - _C)> .abd
    {<(&&, S, C) ==> P>. <(&&, _C, M) ==> P>} |- <((&&, _C, M) - C) ==> ((&&, S, C) - _C)> .abd
    {<(&&, C, S) ==> P>. <(&&, M, _C) ==> P>} |- <((&&, M, _C) - C) ==> ((&&, C, S) - _C)> .abd
    {<(&&, S, C) ==> P>. <(&&, M, _C) ==> P>} |- <((&&, M, _C) - C) ==> ((&&, S, C) - _C)> .abd

    # '{<C ==> P>. S} |- <(&&, C, S) ==> P> .ind (alternative syntax below)
    {<(&&, C, M) ==> P>. (&&, S, M)} |- <(&&, C, S, M) ==> P> .ind
    {<(&&, M, C) ==> P>. (&&, S, M)} |- <(&&, C, S, M) ==> P> .ind
    {<(&&, C, M) ==> P>. (&&, M, S)} |- <(&&, C, S, M) ==> P> .ind
    {<(&&, M, C) ==> P>. (&&, M, S)} |- <(&&, C, S, M) ==> P> .ind

    # '(C ^ M) => P, M => S |- (C ^ S) =>  P (alternative syntax below)
    {<(&&, C, M) ==> P>. <_M ==> S>} |- <(&&, ((&&, C, M) - _M), S) ==> P> .ind
    {<(&&, M, C) ==> P>. <_M ==> S>} |- <(&&, ((&&, M, C) - _M), S) ==> P> .ind

  immediate: |
    S |- (--, S) .neg
    (--, S) |- S .neg
    <S --> P> |- <P --> S> .cnv
    <S ==> P> |- <P ==> S> .cnv
    <S ==> P> |- <(--, P) ==> (--, S)> .cnt

  conditional_compositional: |
    {P. S} |- <S ==> P> .ind
    {P. S} |- <P ==> S> .abd
    {P. S} |- <S <=> P> .com
    {T1. T2} |- (&&, T1, T2) .int
    {T1. T2} |- (&&, T2, T1) .int
    {T1. T2} |- (||, T1, T2) .uni
    {<C ==> P>. S} |- <(&&, C, S) ==> P> .ind
    {<C ==> P>. S} |- <(&&, S, C) ==> P> .ind

theorems: |
  # 'inheritance
  <(T1 & T2) --> T1>
  <T1 --> (T1 | T2)>
  <(T1 - T2) --> T1>
  <((/, R, _, T) * T) --> R>
  <R --> ((\, R, _, T) * T)>

  # 'similarity
  # <(--, (--, T)) <-> T>
  <(/, (T1 * T2), _, T2) <-> T1>
  <(\, (T1 * T2), _, T2) <-> T1>

  # 'implication
  <<S <-> P> ==> <S --> P>>
  <<P <-> S> ==> <S --> P>>
  <<S <=> P> ==> <S ==> P>>
  <<P <=> S> ==> <S ==> P>>
  <(&&, S1, S2) ==> S1>
  <(&&, S1, S2) ==> S2>
  <S1 ==> (||, S1, S2)>
  <S2 ==> (||, S1, S2)>

  <<S --> P> ==> <(S | M) --> (P | M)>>
  <<S --> P> ==> <(S & M) --> (P & M)>>
  <<S <-> P> ==> <(S | M) <-> (P | M)>>
  <<S <-> P> ==> <(S & M) <-> (P & M)>>
  <<P <-> S> ==> <(S | M) <-> (P | M)>>
  <<P <-> S> ==> <(S & M) <-> (P & M)>>

  <<S ==> P> ==> <(S || M) ==> (P || M)>>
  <<S ==> P> ==> <(S && M) ==> (P && M)>>
  <<S <=> P> ==> <(S || M) <=> (P || M)>>
  <<S <=> P> ==> <(S && M) <=> (P && M)>>
  <<P <=> S> ==> <(S || M) <=> (P || M)>>
  <<P <=> S> ==> <(S && M) <=> (P && M)>>

  <<S --> P> ==> <(S - M) --> (P - M)>>
  <<S --> P> ==> <(M - P) --> (M - S)>>
  <<S --> P> ==> <(S ~ M) --> (P ~ M)>>
  <<S --> P> ==> <(M ~ P) --> (M ~ S)>>

  <<S <-> P> ==> <(S - M) <-> (P - M)>>
  <<S <-> P> ==> <(M - P) <-> (M - S)>>
  <<S <-> P> ==> <(S ~ M) <-> (P ~ M)>>
  <<S <-> P> ==> <(M ~ P) <-> (M ~ S)>>
  <<P <-> S> ==> <(S - M) <-> (P - M)>>
  <<P <-> S> ==> <(M - P) <-> (M - S)>>
  <<P <-> S> ==> <(S ~ M) <-> (P ~ M)>>
  <<P <-> S> ==> <(M ~ P) <-> (M ~ S)>>

  <<M --> (T1 - T2)> ==> (--, <M --> T2>)>
  <<(T1 ~ T2) --> M> ==> (--, <T2 --> M>)>

  <<S --> P> ==> <(/, S, _, M) --> (/, P, _, M)>>
  <<S --> P> ==> <(\, S, _, M) --> (\, P, _, M)>>
  <<S --> P> ==> <(/, M, _, P) --> (/, M, _, S)>>
  <<S --> P> ==> <(\, M, _, P) --> (\, M, _, S)>>

  # 'equivalence
  <<S <-> P> <=> <P <-> S>>
  <<S <-> P> <=> (&&, <S --> P>, <P --> S>)>
  <<P <-> S> <=> (&&, <S --> P>, <P --> S>)>
  <<S <=> P> <=> (&&, <S ==> P>, <P ==> S>)>
  <<P <=> S> <=> (&&, <S ==> P>, <P ==> S>)>

  <<S <-> P> <=> <{S} <-> {P}>>
  <<P <-> S> <=> <{S} <-> {P}>>
  <<S <-> P> <=> <[S] <-> [P]>>
  <<P <-> S> <=> <[S] <-> [P]>>

  <<S --> {P}> <=> <S <-> {P}>>
  <<[S] --> P> <=> <[S] <-> P>>

  <<(S1 * S2) --> (P1 * P2)> <=> (&&, <S1 --> P1>, <S2 --> P2>)>
  <<(S1 * S2) <-> (P1 * P2)> <=> (&&, <S1 <-> P1>, <S2 <-> P2>)>
  <<(P1 * P2) <-> (S1 * S2)> <=> (&&, <S1 <-> P1>, <S2 <-> P2>)>

  <<S --> P> <=> <(M * S) --> (M * P)>>
  <<S --> P> <=> <(S * M) --> (P * M)>>
  <<S <-> P> <=> <(M * S) <-> (M * P)>>
  <<S <-> P> <=> <(S * M) <-> (P * M)>>
  <<P <-> S> <=> <(M * S) <-> (M * P)>>
  <<P <-> S> <=> <(S * M) <-> (P * M)>>


  <<(T1 * T2) --> R> <=> <T1 --> (/, R, _, T2)>>
  <<(T1 * T2) --> R> <=> <T2 --> (/, R, T1, _)>>
  <<T1 --> (/, R, _, T2)> <=> <(T1 * T2) --> R>>
  <<T2 --> (/, R, T1, _)> <=> <(T1 * T2) --> R>>
  <<R --> (T1 * T2)> <=> <(\, R, _, T2) --> T1>>
  <<R --> (T1 * T2)> <=> <(\, R, T1, _) --> T2>>
  <<(\, R, _, T2) --> T1> <=> <R --> (T1 * T2)>>
  <<(\, R, T1, _) --> T2> <=> <R --> (T1 * T2)>>

  <<S1 ==> <S2 ==> S3>> <=> <(S1 && S2) ==> S3>>

  <(--, (S1 && S2)) <=> (||, (--, S1), (--, S2))>
  <(--, (S1 && S2)) <=> (&&, (--, S1), (--, S2))>
  <(--, (S2 && S1)) <=> (||, (--, S1), (--, S2))>
  <(--, (S2 && S1)) <=> (&&, (--, S1), (--, S2))>

  <<S1 <=> S2> <=> <(--, S1) <=> (--, S2)>>
  <<S2 <=> S1> <=> <(--, S1) <=> (--, S2)>>

  # 'not in the NAL book but nice to have
  <<T1 --> (/, R, _, T2)> <=> <T2 --> (/, R, T1, _)>>
  <<T2 --> (/, R, T1, _)> <=> <T1 --> (/, R, _, T2)>>
  <<T1 --> (\, R, _, T2)> <=> <T2 --> (\, R, T1, _)>>
  <<T2 --> (\, R, T1, _)> <=> <T1 --> (\, R, _, T2)>>
  # 'inverse of the above 
  <<(/, R, _, T2) --> T1> <=> <(/, R, T1, _) --> T2>>
  <<(/, R, T1, _) --> T2> <=> <(/, R, _, T2) --> T1>>
  <<(\, R, _, T2) --> T1> <=> <(\, R, T1, _) --> T2>>
  <<(\, R, T1, _) --> T2> <=> <(\, R, _, T2) --> T1>>

  <(&/, S1, N1, S2) <=> <S2 =\> (&/, S1, N1)>>
  <(&/, S1, N1, S2) <=> <S1 =/> S2>>
  <(&/, S1, N1, <S2 ==> S3>) <=> <(&/, S1, N1, S2) =/> S3>>

  # <<A =/> B> <=> <B =\> A>>
